<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Air Origin Map (GitHub-only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: system-ui, Arial, sans-serif;
      font-size: 13px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.2);
      max-width: 320px;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div class="info">
  Click the map to compute a simple backward trajectory ensemble (in browser).<br>
  Wind comes from Open-Meteo (no backend).
</div>


    
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Turf.js (for distance, points, etc.) -->
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  
<script src="https://unpkg.com/esri-leaflet@3.0.11/dist/esri-leaflet.js"></script>

<!-- Your shared data loader -->
<script src="origin-data.js"></script>


<script>
  // ─────────────────────────────────────────
  // Map setup
  // ─────────────────────────────────────────
  const map = L.map('map').setView([53.5, -113.5], 6);

  const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 16,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const hrdpsLayer = L.tileLayer.wms("https://geo.weather.gc.ca/geomet/?lang=en", {
    layers: "HRDPS.CONTINENTAL_WSPD",
    format: "image/png",
    transparent: true,
    opacity: 0.5
  }).addTo(map);

  const trajLayerGroup    = L.layerGroup().addTo(map);  // trajectories
  const stationLayerGroup = L.layerGroup().addTo(map);  // AQHI stations
  const purpleLayerGroup  = L.layerGroup().addTo(map);  // PurpleAir
  const npriLayerGroup    = L.layerGroup().addTo(map);  // NPRI facilities

  const baseMaps = {
    "OpenStreetMap": osmLayer
  };

  const overlayMaps = {
    "Trajectories": trajLayerGroup,
    "AQHI Stations": stationLayerGroup,
    "PurpleAir Sensors": purpleLayerGroup,
    "NPRI Facilities": npriLayerGroup,
    "HRDPS Wind (WMS)": hrdpsLayer
  };

  L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);

  // ─────────────────────────────────────────
  // Wind from Open-Meteo
  // ─────────────────────────────────────────
  let lastWind = { u: 8, v: 1, ws: 5.0, wdDeg: 270 };

  async function updateWindFromOpenMeteo(lat, lon) {
    const url = new URL("https://api.open-meteo.com/v1/forecast");
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lon);
    url.searchParams.set("current_weather", "true");

    const resp = await fetch(url.toString());
    if (!resp.ok) {
      console.error("Open-Meteo error:", resp.status, resp.statusText);
      return;
    }

    const data = await resp.json();
    if (!data.current_weather) {
      console.warn("No current_weather in Open-Meteo response");
      return;
    }

    const speed_kmh = data.current_weather.windspeed;      // km/h
    const dir_deg   = data.current_weather.winddirection;  // degrees FROM

    const speed_ms = speed_kmh / 3.6;
    const dir_rad  = dir_deg * Math.PI / 180.0;

    // vector form (u, v) not strictly needed now, but kept for later
    const u = -speed_ms * Math.sin(dir_rad);
    const v = -speed_ms * Math.cos(dir_rad);

    // store both vector and met-style ws/wd
    lastWind = { u, v, ws: speed_ms, wdDeg: dir_deg };
    console.log("Updated wind from Open-Meteo:", lastWind, "(dir from", dir_deg, "°)");
  }

  // ─────────────────────────────────────────
  // Generic helper: get lat/lon from feature
  // ─────────────────────────────────────────
  function getFeatureLatLon(src) {
    if (!src) return null;
    const g = src.geometry || {};

    // GeoJSON Point
    if (g.type === "Point" && Array.isArray(g.coordinates)) {
      const lon = Number(g.coordinates[0]);
      const lat = Number(g.coordinates[1]);
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        return { lat, lon };
      }
    }

    // Esri-style
    if (typeof g.x === "number" && typeof g.y === "number") {
      const lon = Number(g.x);
      const lat = Number(g.y);
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        return { lat, lon };
      }
    }

    // properties fall-back
    const p = src.properties || {};

    const candLat =
      p.lat ??
      p.latitude ??
      p.Latitude ??
      p.LATITUDE ??
      p.LAT ??
      p.y ??
      p.Y;

    const candLon =
      p.lon ??
      p.lng ??
      p.longitude ??
      p.Longitude ??
      p.LONGITUDE ??
      p.LON ??
      p.x ??
      p.X;

    const lat = Number(candLat);
    const lon = Number(candLon);

    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      return { lat, lon };
    }

    return null;
  }

  // ─────────────────────────────────────────
  // Station / Purple / NPRI plotting
  // ─────────────────────────────────────────

  function buildStationParamLines(p) {
    const lines = [];

    function addParam(label, keys, unit) {
      let raw = null;
      for (const k of keys) {
        if (p[k] !== undefined && p[k] !== null) {
          raw = p[k];
          break;
        }
      }
      if (raw === null || raw === undefined) return;
      const val = parseFloat(raw);
      if (!Number.isFinite(val)) return;
      lines.push(`${label}: ${val.toFixed(2)} ${unit}`);
    }

    addParam("SO\u2082",  ["SO2", "so2"], "ppb");
    addParam("NO\u2082",  ["NO2", "no2"], "ppb");
    addParam("NO",       ["NO", "no"],    "ppb");
    addParam("NOx",      ["NOX", "NOx", "nox"], "ppb");
    addParam("O\u2083",  ["O3", "o3"],    "ppb");
    addParam("PM\u2082.\u2085", ["pm25", "PM2_5", "PM2.5", "pm_25"], "µg/m³");
    addParam("CO",       ["CO", "co"],    "ppm");

    return lines;
  }

  function plotStations(fc) {
    stationLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;

    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;

      const p  = f.properties || {};
      const nm = p.stationName || p.StationName || "Station";
      let aq   = p.aqhi ?? p.AQHI ?? "N/A";
      if (!isNaN(+aq)) {
        const v = +aq;
        aq = v > 10 ? "10+" : v.toFixed(0);
      }

      const paramLines = buildStationParamLines(p);
      const paramsHtml = paramLines.length
        ? "<br>" + paramLines.join("<br>")
        : "";

      L.circleMarker([ll.lat, ll.lon], {
        radius: 5,
        color: "#0066cc",
        weight: 1,
        fillOpacity: 0.8
      })
        .bindPopup(`<b>${nm}</b><br>AQHI: ${aq}${paramsHtml}`)
        .addTo(stationLayerGroup);
    });

    console.log("[origin] plotted stations:", fc.features.length);
  }

  function plotPurple(fc) {
    purpleLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;

    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;

      const p  = f.properties || {};
      const nm = p.name || p.Label || p.label || "PurpleAir";
      const pmRaw = p.pm_corr ?? p.pm25 ?? p.PM2_5 ?? p["pm2.5"] ?? "N/A";

      let pmStr = pmRaw;
      const pmVal = parseFloat(pmRaw);
      if (Number.isFinite(pmVal)) {
        pmStr = pmVal.toFixed(2);
      }

      L.circleMarker([ll.lat, ll.lon], {
        radius: 4,
        color: "#8000ff",
        weight: 1,
        fillOpacity: 0.7
      })
        .bindPopup(`<b>${nm}</b><br>PM2.5: ${pmStr} µg/m³`)
        .addTo(purpleLayerGroup);
    });

    console.log("[origin] plotted PurpleAir:", fc.features.length);
  }

  function plotNPRI(fc) {
    npriLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;

    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;

      const p   = f.properties || {};
      const fac = p.FACILITY_NAME || p.FacilityName || p.facility || "Facility";
      const co  = p.COMPANY_NAME  || p.Company      || p.company  || "";
      const yr  = p.REPORTING_YEAR || p.ReportingYear || p.year || "";
      const label = co ? `${fac} (${co})` : fac;

      L.circleMarker([ll.lat, ll.lon], {
        radius: 4,
        color: "#cc0000",
        weight: 1,
        fillOpacity: 0.8
      })
        .bindPopup(`
          <b>${label}</b><br>
          ${yr ? "Year: " + yr + "<br>" : ""}
          <small>${ll.lat.toFixed(4)}, ${ll.lon.toFixed(4)}</small>
        `)
        .addTo(npriLayerGroup);
    });

    console.log("[origin] plotted NPRI:", fc.features.length);
  }

  // ─────────────────────────────────────────
  // Load FCs (from origin-data.js)
  // ─────────────────────────────────────────
  Promise.all([
    window.stationsFCReady,
    window.purpleFCReady,
    window.npriFCReady
  ]).then(() => {
    console.log(
      "[origin init] FC sizes:",
      window.STATIONS_FC.features.length, "stations,",
      window.PURPLE_FC.features.length,   "purple,",
      window.NPRI_FC.features.length,     "npri"
    );

    plotStations(window.STATIONS_FC);
    plotPurple(window.PURPLE_FC);
    plotNPRI(window.NPRI_FC);
  }).catch(err => {
    console.error("[origin init] error plotting layers", err);
  });


  // ─────────────────────────────────────────
  // Simple ensemble using your back-trajectory stepper
  // ─────────────────────────────────────────
  function computeEnsembleTrajectories(startLat, startLon, options = {}) {
    const nParticles = options.nParticles ?? 8;
    const hoursBack  = options.hoursBack  ?? 3;   // default 3 h
    const trajectories = [];

    for (let p = 0; p < nParticles; p++) {
      // small jitter so members don’t sit on top of each other
      const lat0 = startLat + (Math.random() - 0.5) * 0.03;
      const lon0 = startLon + (Math.random() - 0.5) * 0.03;

      const winds = [];
      for (let h = 0; h < hoursBack; h++) {
        // base wind from lastWind (Open-Meteo) with a bit of spread
        const baseWs = Number.isFinite(lastWind.ws)   ? lastWind.ws   : 5.0;
        const baseWd = Number.isFinite(lastWind.wdDeg) ? lastWind.wdDeg : 270;

        const ws = baseWs * (0.7 + 0.6 * Math.random());        // 70–130% of base speed
        const wd = baseWd + (Math.random() - 0.5) * 30;         // ±15° direction jitter

        winds.push({ ws, wd, hours: 1 });
      }

      // Use your existing window.computeBackTrajectory from origin-data.js
      const pts = window.computeBackTrajectory(lat0, lon0, winds);

      // Convert [lat, lon] -> {lat, lon} to match buildFootprint/drawTrajectories
      const traj = pts.map(([lat, lon]) => ({ lat, lon }));
      trajectories.push(traj);
    }

    return trajectories;
  }


  
    // Build a coarse “footprint” grid from ensemble trajectories
    function buildFootprint(trajectories, dlat = 0.05, dlon = 0.05) {
      const counts = new Map();
  
      for (const traj of trajectories) {
        for (const pt of traj) {
          const iy = Math.round(pt.lat / dlat);
          const ix = Math.round(pt.lon / dlon);
          const key = `${iy},${ix}`;
          counts.set(key, (counts.get(key) || 0) + 1);
        }
      }
  
      const cells = [];
      for (const [key, count] of counts.entries()) {
        const [iy, ix] = key.split(",").map(Number);
        cells.push({
          lat: iy * dlat,
          lon: ix * dlon,
          count
        });
      }
      return cells;
    }
  
    // Draw “influence bubbles” from footprint cells
    function drawFootprint(cells) {
      cells.forEach(cell => {
        const radius = 300 + cell.count * 80; // tweak as you like
        L.circle([cell.lat, cell.lon], {
          radius,
          weight: 0,
          fillOpacity: 0.25
        }).addTo(trajLayerGroup);
      });
    }

    // Summarize dominant upwind sector from ensemble trajectories
    function computeDominantDirection(trajectories) {
      const fromBearings = [];
  
      for (const traj of trajectories) {
        if (!traj || traj.length < 2) continue;
  
        // Oldest point (back in time) to receptor (first point)
        const oldest = traj[traj.length - 1];
        const receptor = traj[0];
  
        // Bearing of the *air motion* (oldest → receptor)
        const motionBearing = bearingDeg(
          oldest.lat, oldest.lon,
          receptor.lat, receptor.lon
        );
  
        // Meteorological convention: wind FROM = motion + 180°
        const windFrom = (motionBearing + 180.0) % 360.0;
        fromBearings.push(windFrom);
      }
  
      if (!fromBearings.length) {
        return { sector: null, meanBearing: null, samples: 0 };
      }
  
      // Circular-ish mean (simple average is fine for our rough sectors)
      const meanFrom =
        fromBearings.reduce((sum, b) => sum + b, 0) / fromBearings.length;
  
      // Count which 45° sector wins
      const sectorCounts = {};
      for (const b of fromBearings) {
        const s = bearingToSector(b); // uses your existing helper
        sectorCounts[s] = (sectorCounts[s] || 0) + 1;
      }
  
      const dominantSector = Object.entries(sectorCounts)
        .sort((a, b) => b[1] - a[1])[0][0];
  
      return {
        sector: dominantSector,
        meanBearing: meanFrom,
        samples: fromBearings.length
      };
    }


  
// ─────────────────────────────────────────
// Click handler – 3h centreline + ensemble bubbles
// ─────────────────────────────────────────
map.on("click", async (e) => {
  const { lat, lng } = e.latlng;

  // Make sure all feature collections are ready
  await Promise.all([
    window.stationsFCReady,
    window.purpleFCReady,
    window.npriFCReady
  ]);

  // Clear any previous trajectories / footprints
  trajLayerGroup.clearLayers();

  // Mark receptor
  L.circleMarker(e.latlng, {
    radius: 6,
    color: "#000",
    weight: 2,
    fillColor: "#ff0000",
    fillOpacity: 0.9
  }).addTo(trajLayerGroup);

  try {
    // 1) Update wind at receptor
    await updateWindFromOpenMeteo(lat, lng);

    const ws = Number.isFinite(lastWind.ws)   ? lastWind.ws   : 5.0;
    const wd = Number.isFinite(lastWind.wdDeg) ? lastWind.wdDeg : 270;

    // 2) Simple 3-hour *centreline* using your back-trajectory helpers
    const winds3h = [
      { ws, wd, hours: 1 },
      { ws, wd, hours: 1 },
      { ws, wd, hours: 1 }
    ];

    // computeBackTrajectory & trajectoryToGeoJSON come from origin-data.js
    const trajPoints  = window.computeBackTrajectory(lat, lng, winds3h);
    const trajFeature = window.trajectoryToGeoJSON(trajPoints, {
      start_lat: lat,
      start_lon: lng
    });

    // Draw centreline
    L.geoJSON(trajFeature, {
      style: { weight: 3, opacity: 0.9, color: "#333" }
    }).addTo(trajLayerGroup);

    // 3) Ensemble trajectories + footprint ("bubbles")
    const trajectories = await computeEnsembleTrajectories(lat, lng, {
      nParticles: 8,
      hoursBack: 4,   // change to 4 if you want 4-hour footprint
      dtMinutes: 10
    });

    const footprint = buildFootprint(trajectories);
    const dom       = computeDominantDirection(trajectories);

    // Draw all ensemble members (fainter) + bubbles
    drawTrajectories(trajectories);
    drawFootprint(footprint);

    // 4) Who sits under the plume?  Use the footprint, not just the line
    const stationHits = pointsInFootprint(window.STATIONS_FC, footprint, 20); // km
    const purpleHits  = pointsInFootprint(window.PURPLE_FC,   footprint, 20);
    const npriHits    = pointsInFootprint(window.NPRI_FC,     footprint, 15);

    // 5) Build popup text
    const makeList = (arr, formatter) =>
      arr.length ? arr.slice(0, 5).map(formatter).join("<br>") : "None";

    const stationLines = makeList(
      stationHits,
      h => {
        const p  = h.feature.properties || {};
        const nm = p.stationName || p.StationName || "Station";
        let aq   = p.aqhi ?? p.AQHI ?? "N/A";
        if (!isNaN(+aq)) aq = (+aq > 10 ? "10+" : (+aq).toFixed(0));
        return `${nm} — AQHI: ${aq} (≈${h.dist_km.toFixed(1)} km from footprint)`;
      }
    );

    const purpleLines = makeList(
      purpleHits,
      h => {
        const p   = h.feature.properties || {};
        const nm  = p.name || p.Label || "PurpleAir";
        const pm  = parseFloat(p.pm_corr ?? p.pm25 ?? p.PM2_5 ?? "N/A");
        const pmStr = Number.isFinite(pm) ? pm.toFixed(1) : "N/A";
        return `${nm} — PM2.5: ${pmStr} µg/m³ (≈${h.dist_km.toFixed(1)} km from footprint)`;
      }
    );

    const npriLines = makeList(
      npriHits,
      h => {
        const p   = h.feature.properties || {};
        const fac = p.FACILITY_NAME || "Facility";
        return `${fac} (≈${h.dist_km.toFixed(1)} km from footprint)`;
      }
    );

    const popupHtml = `
      <b>Back-trajectory (~3 hours)</b><br/>
      Wind-from: ${wd.toFixed(0)}° at ${ws.toFixed(1)} m/s<br/>
      Ensemble members: ${dom.samples}<br/>
      Dominant upwind sector: <b>${dom.sector ?? "N/A"}</b><br/>
      Mean wind-from: ${
        dom.meanBearing !== null
          ? dom.meanBearing.toFixed(0) + "&deg;"
          : "N/A"
      }<br/><br/>
      <b>AQHI stations in footprint (~20 km):</b><br/>
      ${stationLines}<br/><br/>
      <b>PurpleAir in footprint (~20 km):</b><br/>
      ${purpleLines}<br/><br/>
      <b>NPRI facilities in footprint (~15 km):</b><br/>
      ${npriLines}
    `;

    L.popup()
      .setLatLng(e.latlng)
      .setContent(popupHtml)
      .openOn(map);

  } catch (err) {
    console.error("Back-trajectory error:", err);
    alert("Could not compute back trajectory. Check console for details.");
  }
});

</script>
