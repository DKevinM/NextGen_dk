<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Air Origin Map (GitHub-only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: system-ui, Arial, sans-serif;
      font-size: 13px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.2);
      max-width: 320px;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div class="info">
  Click the map to compute a simple backward trajectory ensemble (in browser).<br>
  Wind comes from Open-Meteo (no backend).
</div>


    
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Turf.js (for distance, points, etc.) -->
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  
<script src="https://unpkg.com/esri-leaflet@3.0.11/dist/esri-leaflet.js"></script>

<!-- Your shared data loader -->
<script src="origin-data.js"></script>


<script>
  // ─────────────────────────────────────────
  // Map setup
  // ─────────────────────────────────────────
  const map = L.map('map').setView([53.5, -113.5], 6);

  const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 16,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const hrdpsLayer = L.tileLayer.wms("https://geo.weather.gc.ca/geomet/?lang=en", {
    layers: "HRDPS.CONTINENTAL_WSPD",
    format: "image/png",
    transparent: true,
    opacity: 0.5
  }).addTo(map);

  const trajLayerGroup    = L.layerGroup().addTo(map);  // trajectories
  const stationLayerGroup = L.layerGroup().addTo(map);  // AQHI stations
  const purpleLayerGroup  = L.layerGroup().addTo(map);  // PurpleAir
  const npriLayerGroup    = L.layerGroup().addTo(map);  // NPRI facilities

  const baseMaps = {
    "OpenStreetMap": osmLayer
  };

  const overlayMaps = {
    "Trajectories": trajLayerGroup,
    "AQHI Stations": stationLayerGroup,
    "PurpleAir Sensors": purpleLayerGroup,
    "NPRI Facilities": npriLayerGroup,
    "HRDPS Wind (WMS)": hrdpsLayer
  };

  L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);

  // ─────────────────────────────────────────
  // Wind from Open-Meteo
  // ─────────────────────────────────────────
  let lastWind = { u: 8, v: 1, ws: 5.0, wdDeg: 270 };

  async function updateWindFromOpenMeteo(lat, lon) {
    const url = new URL("https://api.open-meteo.com/v1/forecast");
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lon);
    url.searchParams.set("current_weather", "true");

    const resp = await fetch(url.toString());
    if (!resp.ok) {
      console.error("Open-Meteo error:", resp.status, resp.statusText);
      return;
    }

    const data = await resp.json();
    if (!data.current_weather) {
      console.warn("No current_weather in Open-Meteo response");
      return;
    }

    const speed_kmh = data.current_weather.windspeed;      // km/h
    const dir_deg   = data.current_weather.winddirection;  // degrees FROM

    const speed_ms = speed_kmh / 3.6;
    const dir_rad  = dir_deg * Math.PI / 180.0;

    // vector form (u, v) not strictly needed now, but kept for later
    const u = -speed_ms * Math.sin(dir_rad);
    const v = -speed_ms * Math.cos(dir_rad);

    // store both vector and met-style ws/wd
    lastWind = { u, v, ws: speed_ms, wdDeg: dir_deg };
    console.log("Updated wind from Open-Meteo:", lastWind, "(dir from", dir_deg, "°)");
  }

  // ─────────────────────────────────────────
  // Generic helper: get lat/lon from feature
  // ─────────────────────────────────────────
  function getFeatureLatLon(src) {
    if (!src) return null;
    const g = src.geometry || {};

    // GeoJSON Point
    if (g.type === "Point" && Array.isArray(g.coordinates)) {
      const lon = Number(g.coordinates[0]);
      const lat = Number(g.coordinates[1]);
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        return { lat, lon };
      }
    }

    // Esri-style
    if (typeof g.x === "number" && typeof g.y === "number") {
      const lon = Number(g.x);
      const lat = Number(g.y);
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        return { lat, lon };
      }
    }

    // properties fall-back
    const p = src.properties || {};

    const candLat =
      p.lat ??
      p.latitude ??
      p.Latitude ??
      p.LATITUDE ??
      p.LAT ??
      p.y ??
      p.Y;

    const candLon =
      p.lon ??
      p.lng ??
      p.longitude ??
      p.Longitude ??
      p.LONGITUDE ??
      p.LON ??
      p.x ??
      p.X;

    const lat = Number(candLat);
    const lon = Number(candLon);

    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      return { lat, lon };
    }

    return null;
  }

  // ─────────────────────────────────────────
  // Station / Purple / NPRI plotting
  // ─────────────────────────────────────────

  function buildStationParamLines(p) {
    const lines = [];

    function addParam(label, keys, unit) {
      let raw = null;
      for (const k of keys) {
        if (p[k] !== undefined && p[k] !== null) {
          raw = p[k];
          break;
        }
      }
      if (raw === null || raw === undefined) return;
      const val = parseFloat(raw);
      if (!Number.isFinite(val)) return;
      lines.push(`${label}: ${val.toFixed(2)} ${unit}`);
    }

    addParam("SO\u2082",  ["SO2", "so2"], "ppb");
    addParam("NO\u2082",  ["NO2", "no2"], "ppb");
    addParam("NO",       ["NO", "no"],    "ppb");
    addParam("NOx",      ["NOX", "NOx", "nox"], "ppb");
    addParam("O\u2083",  ["O3", "o3"],    "ppb");
    addParam("PM\u2082.\u2085", ["pm25", "PM2_5", "PM2.5", "pm_25"], "µg/m³");
    addParam("CO",       ["CO", "co"],    "ppm");

    return lines;
  }

  function plotStations(fc) {
    stationLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;

    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;

      const p  = f.properties || {};
      const nm = p.stationName || p.StationName || "Station";
      let aq   = p.aqhi ?? p.AQHI ?? "N/A";
      if (!isNaN(+aq)) {
        const v = +aq;
        aq = v > 10 ? "10+" : v.toFixed(0);
      }

      const paramLines = buildStationParamLines(p);
      const paramsHtml = paramLines.length
        ? "<br>" + paramLines.join("<br>")
        : "";

      L.circleMarker([ll.lat, ll.lon], {
        radius: 5,
        color: "#0066cc",
        weight: 1,
        fillOpacity: 0.8
      })
        .bindPopup(`<b>${nm}</b><br>AQHI: ${aq}${paramsHtml}`)
        .addTo(stationLayerGroup);
    });

    console.log("[origin] plotted stations:", fc.features.length);
  }

  function plotPurple(fc) {
    purpleLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;

    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;

      const p  = f.properties || {};
      const nm = p.name || p.Label || p.label || "PurpleAir";
      const pmRaw = p.pm_corr ?? p.pm25 ?? p.PM2_5 ?? p["pm2.5"] ?? "N/A";

      let pmStr = pmRaw;
      const pmVal = parseFloat(pmRaw);
      if (Number.isFinite(pmVal)) {
        pmStr = pmVal.toFixed(2);
      }

      L.circleMarker([ll.lat, ll.lon], {
        radius: 4,
        color: "#8000ff",
        weight: 1,
        fillOpacity: 0.7
      })
        .bindPopup(`<b>${nm}</b><br>PM2.5: ${pmStr} µg/m³`)
        .addTo(purpleLayerGroup);
    });

    console.log("[origin] plotted PurpleAir:", fc.features.length);
  }

  function plotNPRI(fc) {
    npriLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;

    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;

      const p   = f.properties || {};
      const fac = p.FACILITY_NAME || p.FacilityName || p.facility || "Facility";
      const co  = p.COMPANY_NAME  || p.Company      || p.company  || "";
      const yr  = p.REPORTING_YEAR || p.ReportingYear || p.year || "";
      const label = co ? `${fac} (${co})` : fac;

      L.circleMarker([ll.lat, ll.lon], {
        radius: 4,
        color: "#cc0000",
        weight: 1,
        fillOpacity: 0.8
      })
        .bindPopup(`
          <b>${label}</b><br>
          ${yr ? "Year: " + yr + "<br>" : ""}
          <small>${ll.lat.toFixed(4)}, ${ll.lon.toFixed(4)}</small>
        `)
        .addTo(npriLayerGroup);
    });

    console.log("[origin] plotted NPRI:", fc.features.length);
  }

  // ─────────────────────────────────────────
  // Load FCs (from origin-data.js)
  // ─────────────────────────────────────────
  Promise.all([
    window.stationsFCReady,
    window.purpleFCReady,
    window.npriFCReady
  ]).then(() => {
    console.log(
      "[origin init] FC sizes:",
      window.STATIONS_FC.features.length, "stations,",
      window.PURPLE_FC.features.length,   "purple,",
      window.NPRI_FC.features.length,     "npri"
    );

    plotStations(window.STATIONS_FC);
    plotPurple(window.PURPLE_FC);
    plotNPRI(window.NPRI_FC);
  }).catch(err => {
    console.error("[origin init] error plotting layers", err);
  });

  // ─────────────────────────────────────────
  // Click handler – simple 3h back-trajectory
  // ─────────────────────────────────────────
  map.on("click", async (e) => {
    const { lat, lng } = e.latlng;

    await Promise.all([
      window.stationsFCReady,
      window.purpleFCReady,
      window.npriFCReady
    ]);

    trajLayerGroup.clearLayers();

    // Mark receptor
    L.circleMarker(e.latlng, {
      radius: 6,
      color: "#000",
      weight: 2,
      fillColor: "#ff0000",
      fillOpacity: 0.9
    }).addTo(trajLayerGroup);

    try {
      await updateWindFromOpenMeteo(lat, lng);

      const ws = Number.isFinite(lastWind.ws) ? lastWind.ws : 5.0;
      const wd = Number.isFinite(lastWind.wdDeg) ? lastWind.wdDeg : 270;

      // simple 3-hour history with same ws/wd
      const winds3h = [
        { ws, wd, hours: 1 },
        { ws, wd, hours: 1 },
        { ws, wd, hours: 1 }
      ];

      // compute back-trajectory (helpers from origin-data.js)
      const trajPoints = window.computeBackTrajectory(lat, lng, winds3h);
      const trajFeature = window.trajectoryToGeoJSON(trajPoints, {
        start_lat: lat,
        start_lon: lng
      });

      L.geoJSON(trajFeature, {
        style: { weight: 2, opacity: 0.9, color: "#333" }
      }).addTo(trajLayerGroup);

      // find features near the path
      const stationsNear = window.findFeaturesNearTrajectory(trajPoints, window.STATIONS_FC, 20);
      const purpleNear   = window.findFeaturesNearTrajectory(trajPoints, window.PURPLE_FC, 20);
      const npriNear     = window.findFeaturesNearTrajectory(trajPoints, window.NPRI_FC, 15);

      const makeList = (arr, formatter) =>
        arr.length ? arr.slice(0, 5).map(formatter).join("<br>") : "None";

      const stationLines = makeList(
        stationsNear,
        h => {
          const p = h.feature.properties || {};
          const nm = p.stationName || p.StationName || "Station";
          let aq = p.aqhi ?? p.AQHI ?? "N/A";
          if (!isNaN(+aq)) aq = (+aq > 10 ? "10+" : (+aq).toFixed(0));
          return `${nm} — AQHI: ${aq} (≈${h.minDistKm.toFixed(1)} km from path)`;
        }
      );

      const purpleLines = makeList(
        purpleNear,
        h => {
          const p = h.feature.properties || {};
          const nm = p.name || p.Label || "PurpleAir";
          const pm = parseFloat(p.pm_corr ?? p.pm25 ?? p.PM2_5 ?? "N/A");
          const pmStr = Number.isFinite(pm) ? pm.toFixed(1) : "N/A";
          return `${nm} — PM2.5: ${pmStr} µg/m³ (≈${h.minDistKm.toFixed(1)} km from path)`;
        }
      );

      const npriLines = makeList(
        npriNear,
        h => {
          const p = h.feature.properties || {};
          const fac = p.FACILITY_NAME || "Facility";
          return `${fac} (≈${h.minDistKm.toFixed(1)} km from path)`;
        }
      );

      const popupHtml = `
        <b>Simple 3-hour back trajectory</b><br/>
        Wind-from: ${wd.toFixed(0)}° at ${ws.toFixed(1)} m/s<br/><br/>
        <b>AQHI stations near path (~20 km):</b><br/>${stationLines}<br/><br/>
        <b>PurpleAir near path (~20 km):</b><br/>${purpleLines}<br/><br/>
        <b>NPRI facilities (~15 km):</b><br/>${npriLines}
      `;

      L.popup()
        .setLatLng(e.latlng)
        .setContent(popupHtml)
        .openOn(map);

    } catch (err) {
      console.error("Back-trajectory error:", err);
      alert("Could not compute back trajectory. Check console for details.");
    }
  });
</script>

  
