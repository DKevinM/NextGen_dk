<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Air Origin Map (GitHub-only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: system-ui, Arial, sans-serif;
      font-size: 13px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.2);
      max-width: 320px;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div class="info">
  Click the map to compute a simple backward trajectory ensemble (in browser).<br>
  Wind comes from Open-Meteo (no backend).
</div>


    
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Turf.js (for distance, points, etc.) -->
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  
<script src="https://unpkg.com/esri-leaflet@3.0.11/dist/esri-leaflet.js"></script>

<!-- Your shared data loader -->
<script src="origin-data.js"></script>

<script>
  // ─────────────────────────────────────────
  // Map setup
  // ─────────────────────────────────────────
  const map = L.map('map').setView([53.5, -113.5], 6);

  // Base tiles (single OSM layer, keep a handle for layer control)
  const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 16,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // Optional: overlay HRDPS wind speed WMS for visual context only
  const hrdpsLayer = L.tileLayer.wms("https://geo.weather.gc.ca/geomet/?lang=en", {
    layers: "HRDPS.CONTINENTAL_WSPD",
    format: "image/png",
    transparent: true,
    opacity: 0.5
  }).addTo(map);

  const trajLayerGroup    = L.layerGroup().addTo(map);  // trajectories + footprint
  const stationLayerGroup = L.layerGroup().addTo(map);  // AQHI stations
  const purpleLayerGroup  = L.layerGroup().addTo(map);  // PurpleAir
  const npriLayerGroup    = L.layerGroup().addTo(map);  // NPRI facilities

  // NEW: layer control for toggling stations, PurpleAir, NPRI, etc.
  const baseMaps = {
    "OpenStreetMap": osmLayer
  };

  const overlayMaps = {
    "Trajectories & Footprint": trajLayerGroup,
    "AQHI Stations": stationLayerGroup,
    "PurpleAir Sensors": purpleLayerGroup,
    "NPRI Facilities": npriLayerGroup,
    "HRDPS Wind (WMS)": hrdpsLayer
  };

  L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);

  // ─────────────────────────────────────────
  // Global wind + Open-Meteo fetch
  // ─────────────────────────────────────────

  let lastWind = { u: 8, v: 1 };  // default until we fetch real data

  async function updateWindFromOpenMeteo(lat, lon) {
    const url = new URL("https://api.open-meteo.com/v1/forecast");
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lon);
    url.searchParams.set("current_weather", "true");

    const resp = await fetch(url.toString());
    if (!resp.ok) {
      console.error("Open-Meteo error:", resp.status, resp.statusText);
      return;
    }

    const data = await resp.json();
    if (!data.current_weather) {
      console.warn("No current_weather in Open-Meteo response");
      return;
    }

    const speed_kmh = data.current_weather.windspeed;      // km/h
    const dir_deg   = data.current_weather.winddirection;  // degrees FROM

    const speed_ms = speed_kmh / 3.6;
    const dir_rad  = dir_deg * Math.PI / 180.0;

    const u = -speed_ms * Math.sin(dir_rad);
    const v = -speed_ms * Math.cos(dir_rad);
  
    // store both vector and met-style ws/wd
    lastWind = { u, v, ws: speed_ms, wdDeg: dir_deg };
    console.log("Updated wind from Open-Meteo:", lastWind, "(dir from", dir_deg, "°)");

  }

  async function getWindAt(lat, lon) {
    return lastWind;
  }

  // Helper to pull lat/lon from either geometry or properties
  function getFeatureLatLon(src) {
    if (!src) return null;
    const g = src.geometry || {};

    if (g.type === "Point" && Array.isArray(g.coordinates)) {
      const lon = Number(g.coordinates[0]);
      const lat = Number(g.coordinates[1]);
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        return { lat, lon };
      }
    }

    if (typeof g.x === "number" && typeof g.y === "number") {
      const lon = Number(g.x);
      const lat = Number(g.y);
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        return { lat, lon };
      }
    }

    const p = src.properties || {};

    const candLat =
      p.lat ??
      p.latitude ??
      p.Latitude ??
      p.LATITUDE ??
      p.LAT ??
      p.y ??
      p.Y;

    const candLon =
      p.lon ??
      p.lng ??
      p.longitude ??
      p.Longitude ??
      p.LONGITUDE ??
      p.LON ??
      p.x ??
      p.X;

    const lat = Number(candLat);
    const lon = Number(candLon);

    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      return { lat, lon };
    }

    return null;
  }

  // which points are within radiusKm of *any* footprint cell
  function pointsInFootprint(srcFC, cells, radiusKm = 20) {
    if (!srcFC || !Array.isArray(srcFC.features) || !cells?.length) {
      return [];
    }

    const hits = [];

    for (const src of srcFC.features) {
      const ll = getFeatureLatLon(src);
      if (!ll) continue;

      const pt = turf.point([ll.lon, ll.lat]);

      let best = Infinity;
      for (const cell of cells) {
        const cellPt = turf.point([cell.lon, cell.lat]);
        const d = turf.distance(pt, cellPt, { units: "kilometers" });
        if (d < best) best = d;
      }

      if (best <= radiusKm) {
        hits.push({ feature: src, dist_km: best });
      }
    }

    hits.sort((a, b) => a.dist_km - b.dist_km);
    return hits;
  }

  // Trajectory math helpers
  const EARTH_RADIUS_M = 6371000.0;

  function uvToLatLonStep(latDeg, u, v, dtSeconds) {
    const latRad = latDeg * Math.PI / 180.0;
    const dlat = (v * dtSeconds) / EARTH_RADIUS_M * (180.0 / Math.PI);
    const dlon = (u * dtSeconds) / (EARTH_RADIUS_M * Math.cos(latRad)) * (180.0 / Math.PI);
    return { dlat, dlon };
  }

  function bearingDeg(lat1, lon1, lat2, lon2) {
    const phi1 = lat1 * Math.PI / 180.0;
    const phi2 = lat2 * Math.PI / 180.0;
    const dlon = (lon2 - lon1) * Math.PI / 180.0;

    const x = Math.sin(dlon) * Math.cos(phi2);
    const y = Math.cos(phi1) * Math.sin(phi2) -
              Math.sin(phi1) * Math.cos(phi2) * Math.cos(dlon);

    const brng = Math.atan2(x, y) * 180.0 / Math.PI;
    return (brng + 360.0) % 360.0;
  }

  function bearingFromStationToReceptor(stLat, stLon, rLat, rLon) {
    return bearingDeg(stLat, stLon, rLat, rLon);
  }

  function bearingToSector(bearing) {
    const labels = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
    const sectorSize = 360.0 / labels.length;
    const idx = Math.floor((bearing + sectorSize / 2.0) / sectorSize) % labels.length;
    return labels[idx];
  }

  async function computeEnsembleTrajectories(startLat, startLon, options = {}) {
    const nParticles = options.nParticles ?? 8;
    const hoursBack  = options.hoursBack ?? 2.0;
    const dtMinutes  = options.dtMinutes ?? 10;
    const dtSeconds  = dtMinutes * 60.0;
    const nSteps     = Math.round(hoursBack * 60.0 / dtMinutes);

    const trajectories = [];

    for (let p = 0; p < nParticles; p++) {
      let lat = startLat + (Math.random() - 0.5) * 0.03;
      let lon = startLon + (Math.random() - 0.5) * 0.03;

      const traj = [{ lat, lon }];

      for (let k = 0; k < nSteps; k++) {
        const { u, v } = await getWindAt(lat, lon);
        const { dlat, dlon } = uvToLatLonStep(lat, u, v, dtSeconds);

        lat -= dlat;
        lon -= dlon;

        traj.push({ lat, lon });
      }

      trajectories.push(traj);
    }

    return trajectories;
  }

  function buildFootprint(trajectories, dlat = 0.05, dlon = 0.05) {
    const counts = new Map();

    for (const traj of trajectories) {
      for (const pt of traj) {
        const iy = Math.round(pt.lat / dlat);
        const ix = Math.round(pt.lon / dlon);
        const key = `${iy},${ix}`;
        counts.set(key, (counts.get(key) || 0) + 1);
      }
    }

    const cells = [];
    for (const [key, count] of counts.entries()) {
      const [iy, ix] = key.split(",").map(Number);
      cells.push({
        lat: iy * dlat,
        lon: ix * dlon,
        count
      });
    }
    return cells;
  }

  function computeDominantDirection(trajectories) {
    const fromBearings = [];

    for (const traj of trajectories) {
      if (traj.length < 2) continue;

      const start = traj[traj.length - 1];
      const end   = traj[0];

      const motionBearing = bearingDeg(start.lat, start.lon, end.lat, end.lon);
      const windFrom = (motionBearing + 180.0) % 360.0;

      fromBearings.push(windFrom);
    }

    if (!fromBearings.length) {
      return { sector: null, meanBearing: null, samples: 0 };
    }

    const meanFrom = fromBearings.reduce((a, b) => a + b, 0) / fromBearings.length;

    const sectorCounts = {};
    for (const b of fromBearings) {
      const s = bearingToSector(b);
      sectorCounts[s] = (sectorCounts[s] || 0) + 1;
    }
    const dominantSector = Object.entries(sectorCounts)
      .sort((a, b) => b[1] - a[1])[0][0];

    return {
      sector: dominantSector,
      meanBearing: meanFrom,
      samples: fromBearings.length
    };
  }

  function drawTrajectories(trajectories) {
    trajectories.forEach(traj => {
      const latlngs = traj.map(pt => [pt.lat, pt.lon]);
      L.polyline(latlngs, {
        weight: 2,
        opacity: 0.9
      }).addTo(trajLayerGroup);
    });
  }

  function drawFootprint(cells) {
    cells.forEach(cell => {
      const radius = 300 + cell.count * 80;
      L.circle([cell.lat, cell.lon], {
        radius,
        weight: 0,
        fillOpacity: 0.25
      }).addTo(trajLayerGroup);
    });
  }

  // NEW: helper to extract pollutant parameters from station properties
  function buildStationParamLines(p) {
    const lines = [];

    function addParam(label, keys, unit) {
      let raw = null;
      for (const k of keys) {
        if (p[k] !== undefined && p[k] !== null) {
          raw = p[k];
          break;
        }
      }
      if (raw === null || raw === undefined) return;
      const val = parseFloat(raw);
      if (!Number.isFinite(val)) return;
      lines.push(`${label}: ${val.toFixed(2)} ${unit}`);
    }

    addParam("SO\u2082",  ["SO2", "so2"], "ppb");
    addParam("NO\u2082",  ["NO2", "no2"], "ppb");
    addParam("NO",       ["NO", "no"],    "ppb");
    addParam("NOx",      ["NOX", "NOx", "nox"], "ppb");
    addParam("O\u2083",  ["O3", "o3"],    "ppb");
    addParam("PM\u2082.\u2085", ["pm25", "PM2_5", "PM2.5", "pm_25"], "µg/m³");
    addParam("CO",       ["CO", "co"],    "ppm");

    return lines;
  }

  function plotStations(fc) {
    stationLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;

    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;

      const p  = f.properties || {};
      const nm = p.stationName || p.StationName || "Station";
      let aq   = p.aqhi ?? p.AQHI ?? "N/A";
      if (!isNaN(+aq)) {
        const v = +aq;
        aq = v > 10 ? "10+" : v.toFixed(0);
      }

      // NEW: pull parameters (SO2, NO2, O3, PM2.5, etc.)
      const paramLines = buildStationParamLines(p);
      const paramsHtml = paramLines.length
        ? "<br>" + paramLines.join("<br>")
        : "";

      L.circleMarker([ll.lat, ll.lon], {
        radius: 5,
        color: "#0066cc",
        weight: 1,
        fillOpacity: 0.8
      })
        .bindPopup(`<b>${nm}</b><br>AQHI: ${aq}${paramsHtml}`)
        .addTo(stationLayerGroup);
    });

    console.log("[origin] plotted stations:", fc.features.length);
  }

  function plotPurple(fc) {
    purpleLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;

    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;

      const p  = f.properties || {};
      const nm = p.name || p.Label || p.label || "PurpleAir";
      const pmRaw = p.pm_corr ?? p.pm25 ?? p.PM2_5 ?? p["pm2.5"] ?? "N/A";

      let pmStr = pmRaw;
      const pmVal = parseFloat(pmRaw);
      if (Number.isFinite(pmVal)) {
        pmStr = pmVal.toFixed(2);    // 2 decimal places
      }

      L.circleMarker([ll.lat, ll.lon], {
        radius: 4,
        color: "#8000ff",
        weight: 1,
        fillOpacity: 0.7
      })
        .bindPopup(`<b>${nm}</b><br>PM2.5: ${pmStr} µg/m³`)
        .addTo(purpleLayerGroup);
    });

    console.log("[origin] plotted PurpleAir:", fc.features.length);
  }

  function plotNPRI(fc) {
    npriLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;

    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;

      const p   = f.properties || {};
      const fac = p.FACILITY_NAME || p.FacilityName || p.facility || "Facility";
      const co  = p.COMPANY_NAME  || p.Company      || p.company  || "";
      const yr  = p.REPORTING_YEAR || p.ReportingYear || p.year || "";
      const label = co ? `${fac} (${co})` : fac;

      L.circleMarker([ll.lat, ll.lon], {
        radius: 4,
        color: "#cc0000",
        weight: 1,
        fillOpacity: 0.8
      })
        .bindPopup(`
          <b>${label}</b><br>
          ${yr ? "Year: " + yr + "<br>" : ""}
          <small>${ll.lat.toFixed(4)}, ${ll.lon.toFixed(4)}</small>
        `)
        .addTo(npriLayerGroup);
    });

    console.log("[origin] plotted NPRI:", fc.features.length);
  }

  Promise.all([
    window.stationsFCReady,
    window.purpleFCReady,
    window.npriFCReady
  ]).then(() => {
    console.log(
      "[origin init] FC sizes:",
      window.STATIONS_FC.features.length, "stations,",
      window.PURPLE_FC.features.length,   "purple,",
      window.NPRI_FC.features.length,     "npri"
    );

    plotStations(window.STATIONS_FC);
    plotPurple(window.PURPLE_FC);
    plotNPRI(window.NPRI_FC);
  }).catch(err => {
    console.error("[origin init] error plotting layers", err);
  });


    // ─────────────────────────────────────────
  // Click handler – simple 3h back-trajectory
  // ─────────────────────────────────────────
  map.on("click", async (e) => {
    const { lat, lng } = e.latlng;

    // Ensure station / Purple / NPRI FeatureCollections are loaded
    await Promise.all([
      window.stationsFCReady,
      window.purpleFCReady,
      window.npriFCReady
    ]);

    trajLayerGroup.clearLayers();

    // Mark the receptor
    L.circleMarker(e.latlng, {
      radius: 6,
      color: "#000",
      weight: 2,
      fillColor: "#ff0000",
      fillOpacity: 0.9
    }).addTo(trajLayerGroup);

    try {
      // Get current wind at the click location
      await updateWindFromOpenMeteo(lat, lng);

      // Build a simple 3-hour history using the same ws/wd for each hour (for now)
      const ws = (lastWind.ws && Number.isFinite(lastWind.ws))
        ? lastWind.ws
        : 5.0;          // fallback
      const wd = (lastWind.wdDeg && Number.isFinite(lastWind.wdDeg))
        ? lastWind.wdDeg
        : 270;          // fallback

      const winds3h = [
        { ws, wd, hours: 1 }, // 0–1 h back
        { ws, wd, hours: 1 }, // 1–2 h back
        { ws, wd, hours: 1 }  // 2–3 h back
      ];

      // 1) Compute back-trajectory points (using helpers from origin-data.js)
      const trajPoints = window.computeBackTrajectory(lat, lng, winds3h);
      const trajFeature = window.trajectoryToGeoJSON(trajPoints, {
        start_lat: lat,
        start_lon: lng
      });

      // Draw the trajectory line
      L.geoJSON(trajFeature, {
        style: { weight: 2, opacity: 0.9, color: "#333" }
      }).addTo(trajLayerGroup);

      // 2) Find features near the path
      const stationsNear = window.findFeaturesNearTrajectory(
        trajPoints,
        window.STATIONS_FC,
        20   // km radius around path
      );
      const purpleNear = window.findFeaturesNearTrajectory(
        trajPoints,
        window.PURPLE_FC,
        20
      );
      const npriNear = window.findFeaturesNearTrajectory(
        trajPoints,
        window.NPRI_FC,
        15
      );

      // 3) Build summary text

      let stationLines = "None";
      if (stationsNear.length) {
        stationLines = stationsNear
          .slice(0, 5)
          .map(h => {
            const p  = h.feature.properties || {};
            const nm = p.stationName || p.StationName || "Station";
            let aq   = p.aqhi ?? p.AQHI ?? "N/A";
            if (!isNaN(+aq)) {
              const v = +aq;
              aq = v > 10 ? "10+" : v.toFixed(0);
            }
            const dkm = h.minDistKm.toFixed(1);
            return `${nm} — AQHI: ${aq} (≈${dkm} km from path)`;
          })
          .join("<br>");
      }

      let purpleLines = "None";
      if (purpleNear.length) {
        purpleLines = purpleNear
          .slice(0, 5)
          .map(h => {
            const p  = h.feature.properties || {};
            const nm = p.name || p.Label || p.label || "PurpleAir";
            const pmRaw = p.pm_corr ?? p.pm25 ?? p.PM2_5 ?? p["pm2.5"] ?? "N/A";
            let pmStr = pmRaw;
            const pmVal = parseFloat(pmRaw);
            if (Number.isFinite(pmVal)) pmStr = pmVal.toFixed(1);
            const dkm = h.minDistKm.toFixed(1);
            return `${nm} — PM2.5: ${pmStr} µg/m³ (≈${dkm} km from path)`;
          })
          .join("<br>");
      }

      let npriLines = "None";
      if (npriNear.length) {
        npriLines = npriNear
          .slice(0, 10)
          .map(h => {
            const p   = h.feature.properties || {};
            const fac = p.FACILITY_NAME || p.FacilityName || p.facility || "NPRI facility";
            const dkm = h.minDistKm.toFixed(1);
            return `${fac} (≈${dkm} km from path)`;
          })
          .join("<br>");
      }

      const popupHtml = `
        <b>Simple 3-hour back trajectory</b><br/>
        Wind-from: ${wd.toFixed(0)}&deg;, speed: ${ws.toFixed(1)} m/s<br/><br/>
        <b>Stations near path (~20 km):</b><br/>
        ${stationLines}<br/><br/>
        <b>PurpleAir near path (~20 km):</b><br/>
        ${purpleLines}<br/><br/>
        <b>NPRI facilities near path (~15 km):</b><br/>
        ${npriLines}
      `;

      L.popup()
        .setLatLng(e.latlng)
        .setContent(popupHtml)
        .openOn(map);

    } catch (err) {
      console.error("Back-trajectory error:", err);
      alert("Could not compute back trajectory. Check console for details.");
    }
  });

      

      // draw a simple wind arrow at the receptor using lastWind
      function drawWindArrow(lat, lon, u, v) {
        const len = 0.3; // degrees scaled; tweak
        const mag = Math.sqrt(u*u + v*v) || 1;
        const scale = len / mag;
      
        const endLat = lat + v * scale * 0.01;
        const endLon = lon + u * scale * 0.01;
      
        L.polyline([[lat, lon], [endLat, endLon]], {
          weight: 3,
          opacity: 0.9,
          color: "#333"
        }).addTo(trajLayerGroup);
      }


      
      const footprint = buildFootprint(trajectories);
      const dom = computeDominantDirection(trajectories);

      drawTrajectories(trajectories);
      drawFootprint(footprint);

      const stationHits = pointsInFootprint(window.STATIONS_FC, footprint, 20);
      const purpleHits  = pointsInFootprint(window.PURPLE_FC,   footprint, 20);
      const npriHits    = pointsInFootprint(window.NPRI_FC,     footprint, 15);

      const receptorPt = turf.point([lng, lat]);

      let stationUpwind = stationHits.filter(h => {
        const ll = getFeatureLatLon(h.feature);
        if (!ll) return false;
        
        const brg = bearingDeg(lat, lng, ll.lat, ll.lon);
        const stSector = bearingToSector(brg);
              
        return !dom.sector || stSector === dom.sector;
      });

      if (!stationUpwind.length && window.STATIONS_FC && Array.isArray(window.STATIONS_FC.features)) {
        stationUpwind = window.STATIONS_FC.features
          .map(f => {
            const ll = getFeatureLatLon(f);
            if (!ll) return null;
            const fpt = turf.point([ll.lon, ll.lat]);
            const d   = turf.distance(receptorPt, fpt, { units: "kilometers" });
            const brg = bearingFromStationToReceptor(ll.lat, ll.lon, lat, lng);
            const stSector = bearingToSector(brg);
            return { feature: f, dist_km: d, sector: stSector };
          })
          .filter(h =>
            h &&
            h.dist_km <= 50 &&
            (!dom.sector || h.sector === dom.sector)
          )
          .sort((a, b) => a.dist_km - b.dist_km)
          .slice(0, 3);
      }

      let npriHitsFinal = npriHits;
      if (!npriHits.length && NPRI_FC && Array.isArray(NPRI_FC.features)) {
        const receptorPt = turf.point([lng, lat]);

        const allWithDist = NPRI_FC.features
          .map(f => {
            const ll = getFeatureLatLon(f);
            if (!ll) return null;
            const fpt = turf.point([ll.lon, ll.lat]);
            const d   = turf.distance(receptorPt, fpt, { units: "kilometers" });
            return { feature: f, dist_km: d };
          })
          .filter(Boolean)
          .sort((a, b) => a.dist_km - b.dist_km);

        npriHitsFinal = allWithDist.filter(h => h.dist_km <= 50).slice(0, 3);
      }

      // Stations summary text (still AQHI-focused, with 2-decimal distances)
      let stationLines = "Aucun";
      if (stationUpwind.length) {
        stationLines = stationUpwind
          .slice(0, 3)
          .map(h => {
            const p   = h.feature.properties || {};
            const nm  = p.stationName || p.StationName || "Station";
            let aq    = p.aqhi ?? p.AQHI ?? "N/A";
            if (!isNaN(+aq)) {
              const v = +aq;
              aq = v > 10 ? "10+" : v.toFixed(0);
            }
            const dkm = h.dist_km.toFixed(1);  // 2 decimal places
            return `${nm} — AQHI: ${aq} (≈${dkm} km)`;
          })
          .join("<br>");
      }

      // Purple summary text with PM to 2 decimals
      let purpleLines = "Aucun";
      if (purpleHits.length) {
        purpleLines = purpleHits
          .slice(0, 5)
          .map(h => {
            const p   = h.feature.properties || {};
            const nm  = p.name || p.Label || p.label || "PurpleAir";
            const pmRaw = p.pm_corr ?? p.pm25 ?? p.PM2_5 ?? p["pm2.5"] ?? "N/A";
            let pmStr = pmRaw;
            const pmVal = parseFloat(pmRaw);
            if (Number.isFinite(pmVal)) {
              pmStr = pmVal.toFixed(1);
            }
            const dkm = h.dist_km.toFixed(1);
            return `${nm} — PM2.5: ${pmStr} µg/m³ (≈${dkm} km)`;
          })
          .join("<br>");
      }

      // NPRI summary text with distance to 2 decimals
      let npriLines = "Aucun";
      if (npriHitsFinal.length) {
        npriLines = npriHitsFinal
          .slice(0, 10)
          .map(h => {
            const p   = h.feature.properties || {};
            const fac = p.FACILITY_NAME || p.FacilityName || p.facility || "Installation NPRI";
            const co  = p.COMPANY_NAME  || p.Company      || p.company  || "";
            const yr  = p.REPORTING_YEAR || p.ReportingYear || p.year || "";
            const dkm = h.dist_km.toFixed(2);
            // const label = co ? `${fac} (${co})` : fac
            const label = fac;
            return `${label} ≈${dkm} km`;
          })
          .join("<br>");
      }

      const popupHtml = `
        <b>Air origin (last ~2 hours)</b><br/>
        Dominant upwind sector: <b>${dom.sector ?? "N/A"}</b><br/>
        Mean wind-from direction: ${
          dom.meanBearing !== null
            ? dom.meanBearing.toFixed(0) + "&deg;"
            : "N/A"
        }<br/>
        Ensemble members: ${dom.samples}<br/><br/>
        <b>Upwind AQ stations (~20 km, possible source region):</b><br/>
        ${stationLines}<br/><br/>
        <b>Upwind PurpleAir sensors (~20 km, top 5):</b><br/>
        ${purpleLines}<br/><br/>
        <b>Upwind NPRI facilities (~15 km, top 10):</b><br/>
        ${npriLines}
      `;

      L.popup()
        .setLatLng(e.latlng)
        .setContent(popupHtml)
        .openOn(map);

    } catch (err) {
      console.error("Trajectory computation error:", err);
      alert("Could not compute trajectories. Check console for details.");
    }
  });
</script>

  
