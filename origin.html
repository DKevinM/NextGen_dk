<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Air Origin Map (GitHub-only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: system-ui, Arial, sans-serif;
      font-size: 13px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.2);
      max-width: 320px;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div class="info">
  Click the map to compute a simple backward trajectory ensemble (in browser).<br>
  Wind comes from Open-Meteo (no backend).
</div>


    
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Turf.js (for distance, points, etc.) -->
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  
<!-- Your shared data loader -->
<script src="origin-data.js"></script>


  
<script>
  // ─────────────────────────────────────────
  // Map setup
  // ─────────────────────────────────────────
  const map = L.map('map').setView([53.5, -113.5], 6);

  // Base tiles
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 10,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // Optional: overlay HRDPS wind speed WMS for visual context only
  L.tileLayer.wms("https://geo.weather.gc.ca/geomet/?lang=en", {
    layers: "HRDPS.CONTINENTAL_WSPD",
    format: "image/png",
    transparent: true,
    opacity: 0.5
  }).addTo(map);

  const trajLayerGroup    = L.layerGroup().addTo(map);  // trajectories + footprint
  const stationLayerGroup = L.layerGroup().addTo(map);  // AQHI stations
  const purpleLayerGroup  = L.layerGroup().addTo(map);  // PurpleAir
  const npriLayerGroup    = L.layerGroup().addTo(map);  // NPRI facilities

  const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 10,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);



  // ─────────────────────────────────────────
  // Global wind + Open-Meteo fetch
  // ─────────────────────────────────────────

  // Global "current wind" used by the trajectories for the last click
  // units: m/s, u = eastward, v = northward
  let lastWind = { u: 8, v: 1 };  // default until we fetch real data

  // Fetch real wind from Open-Meteo at the click location
  async function updateWindFromOpenMeteo(lat, lon) {
    const url = new URL("https://api.open-meteo.com/v1/forecast");
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lon);
    url.searchParams.set("current_weather", "true");

    const resp = await fetch(url.toString());
    if (!resp.ok) {
      console.error("Open-Meteo error:", resp.status, resp.statusText);
      return;
    }

    const data = await resp.json();
    if (!data.current_weather) {
      console.warn("No current_weather in Open-Meteo response");
      return;
    }

    const speed_kmh = data.current_weather.windspeed;      // km/h
    const dir_deg   = data.current_weather.winddirection;  // degrees FROM

    // Convert speed to m/s
    const speed_ms = speed_kmh / 3.6;

    // Open-Meteo direction = where wind is COMING FROM (met convention)
    const dir_rad = dir_deg * Math.PI / 180.0;

    // Flow components (toward where air is going)
    // u = eastward, v = northward
    // negative because the dir is "from"
    const u = -speed_ms * Math.sin(dir_rad);
    const v = -speed_ms * Math.cos(dir_rad);

    lastWind = { u, v };
    console.log("Updated wind from Open-Meteo:", lastWind, "(dir from", dir_deg, "°)");
  }

  // For now we ignore lat/lon here and just use lastWind,
  // which is updated once per click by updateWindFromOpenMeteo.
  async function getWindAt(lat, lon) {
    return lastWind;
  }



// which points in footprints of wind.  
// Helper to pull lat/lon from either geometry or properties
function getFeatureLatLon(src) {
  if (!src) return null;
  const g = src.geometry || {};

  // 1) Standard GeoJSON Point
  if (g.type === "Point" && Array.isArray(g.coordinates)) {
    const lon = Number(g.coordinates[0]);
    const lat = Number(g.coordinates[1]);
    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      return { lat, lon };
    }
  }

  // 2) Esri-style geometry { x: ..., y: ... }
  if (typeof g.x === "number" && typeof g.y === "number") {
    const lon = Number(g.x);
    const lat = Number(g.y);
    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      return { lat, lon };
    }
  }

  // 3) Fallback to properties-based coords
  const p = src.properties || {};

  const candLat =
    p.lat ??
    p.latitude ??
    p.Latitude ??
    p.LATITUDE ??
    p.LAT ??
    p.y ??
    p.Y;

  const candLon =
    p.lon ??
    p.lng ??
    p.longitude ??
    p.Longitude ??
    p.LONGITUDE ??
    p.LON ??
    p.x ??
    p.X;

  const lat = Number(candLat);
  const lon = Number(candLon);

  if (Number.isFinite(lat) && Number.isFinite(lon)) {
    return { lat, lon };
  }

  return null;
}




  

// which points are within radiusKm of *any* footprint cell
function pointsInFootprint(srcFC, cells, radiusKm = 20) {
  if (!srcFC || !Array.isArray(srcFC.features) || !cells?.length) {
    return [];
  }

  const hits = [];

  for (const src of srcFC.features) {
    const ll = getFeatureLatLon(src);
    if (!ll) continue;

    const pt = turf.point([ll.lon, ll.lat]);

    let best = Infinity;
    for (const cell of cells) {
      const cellPt = turf.point([cell.lon, cell.lat]);
      const d = turf.distance(pt, cellPt, { units: "kilometers" });
      if (d < best) best = d;
    }

    if (best <= radiusKm) {
      hits.push({ feature: src, dist_km: best });
    }
  }

  hits.sort((a, b) => a.dist_km - b.dist_km);
  return hits;
}




  
  // ─────────────────────────────────────────
  // Trajectory math helpers (JS versions)
  // ─────────────────────────────────────────
  const EARTH_RADIUS_M = 6371000.0;

  function uvToLatLonStep(latDeg, u, v, dtSeconds) {
    const latRad = latDeg * Math.PI / 180.0;
    const dlat = (v * dtSeconds) / EARTH_RADIUS_M * (180.0 / Math.PI);
    const dlon = (u * dtSeconds) / (EARTH_RADIUS_M * Math.cos(latRad)) * (180.0 / Math.PI);
    return { dlat, dlon };
  }

  function bearingDeg(lat1, lon1, lat2, lon2) {
    const phi1 = lat1 * Math.PI / 180.0;
    const phi2 = lat2 * Math.PI / 180.0;
    const dlon = (lon2 - lon1) * Math.PI / 180.0;

    const x = Math.sin(dlon) * Math.cos(phi2);
    const y = Math.cos(phi1) * Math.sin(phi2) -
              Math.sin(phi1) * Math.cos(phi2) * Math.cos(dlon);

    const brng = Math.atan2(x, y) * 180.0 / Math.PI;
    return (brng + 360.0) % 360.0;
  }

  
  function bearingFromStationToReceptor(stLat, stLon, rLat, rLon) {
    // direction wind must come FROM to reach receptor from station
    return bearingDeg(stLat, stLon, rLat, rLon);
  }

  
  function bearingToSector(bearing) {
    const labels = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
    const sectorSize = 360.0 / labels.length;
    const idx = Math.floor((bearing + sectorSize / 2.0) / sectorSize) % labels.length;
    return labels[idx];
  }

  // ─────────────────────────────────────────
  // Core: compute ensemble trajectories in browser
  // ─────────────────────────────────────────
  async function computeEnsembleTrajectories(startLat, startLon, options = {}) {
    const nParticles = options.nParticles ?? 8;
    const hoursBack  = options.hoursBack ?? 2.0;
    const dtMinutes  = options.dtMinutes ?? 10;
    const dtSeconds  = dtMinutes * 60.0;
    const nSteps     = Math.round(hoursBack * 60.0 / dtMinutes);

    const trajectories = [];

    for (let p = 0; p < nParticles; p++) {
      let lat = startLat + (Math.random() - 0.5) * 0.03;
      let lon = startLon + (Math.random() - 0.5) * 0.03;

      const traj = [{ lat, lon }];

      for (let k = 0; k < nSteps; k++) {
        const { u, v } = await getWindAt(lat, lon);

        const { dlat, dlon } = uvToLatLonStep(lat, u, v, dtSeconds);

        // backward = move opposite flow
        lat -= dlat;
        lon -= dlon;

        traj.push({ lat, lon });
      }

      trajectories.push(traj);
    }

    return trajectories;
  }

  function buildFootprint(trajectories, dlat = 0.05, dlon = 0.05) {
    const counts = new Map();

    for (const traj of trajectories) {
      for (const pt of traj) {
        const iy = Math.round(pt.lat / dlat);
        const ix = Math.round(pt.lon / dlon);
        const key = `${iy},${ix}`;
        counts.set(key, (counts.get(key) || 0) + 1);
      }
    }

    const cells = [];
    for (const [key, count] of counts.entries()) {
      const [iy, ix] = key.split(",").map(Number);
      cells.push({
        lat: iy * dlat,
        lon: ix * dlon,
        count
      });
    }
    return cells;
  }

  // Dominant direction in meteorological "from" convention
  function computeDominantDirection(trajectories) {
    const fromBearings = [];

    for (const traj of trajectories) {
      if (traj.length < 2) continue;

      // start = oldest point (upwind), end = receptor
      const start = traj[traj.length - 1];
      const end   = traj[0];

      // direction of motion (from start -> end)
      const motionBearing = bearingDeg(start.lat, start.lon, end.lat, end.lon);

      // meteorological convention: direction air is COMING FROM
      const windFrom = (motionBearing + 180.0) % 360.0;

      fromBearings.push(windFrom);
    }

    if (!fromBearings.length) {
      return { sector: null, meanBearing: null, samples: 0 };
    }

    const meanFrom = fromBearings.reduce((a, b) => a + b, 0) / fromBearings.length;

    const sectorCounts = {};
    for (const b of fromBearings) {
      const s = bearingToSector(b);
      sectorCounts[s] = (sectorCounts[s] || 0) + 1;
    }
    const dominantSector = Object.entries(sectorCounts)
      .sort((a, b) => b[1] - a[1])[0][0];

    return {
      sector: dominantSector,   // e.g., "W" = wind FROM west
      meanBearing: meanFrom,    // numeric wind-from direction (deg)
      samples: fromBearings.length
    };
  }

  // ─────────────────────────────────────────
  // Draw trajectories + footprint
  // ─────────────────────────────────────────
  function drawTrajectories(trajectories) {
    trajectories.forEach(traj => {
      const latlngs = traj.map(pt => [pt.lat, pt.lon]);
      L.polyline(latlngs, {
        weight: 2,
        opacity: 0.9
      }).addTo(trajLayerGroup);
    });
  }

  function drawFootprint(cells) {
    cells.forEach(cell => {
      const radius = 300 + cell.count * 80; // metres
      L.circle([cell.lat, cell.lon], {
        radius,
        weight: 0,
        fillOpacity: 0.25
      }).addTo(trajLayerGroup);
    });
  }

  
  function plotStations(fc) {
    stationLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;
  
    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;
  
      const p  = f.properties || {};
      const nm = p.stationName || p.StationName || "Station";
      let aq   = p.aqhi ?? p.AQHI ?? "N/A";
      if (!isNaN(+aq)) aq = +aq > 10 ? "10+" : aq;
  
      L.circleMarker([ll.lat, ll.lon], {
        radius: 5,
        color: "#0066cc",
        weight: 1,
        fillOpacity: 0.8
      })
        .bindPopup(`<b>${nm}</b><br>AQHI: ${aq}`)
        .addTo(stationLayerGroup);
    });
  
    console.log("[origin] plotted stations:", fc.features.length);
  }
  
  function plotPurple(fc) {
    purpleLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;
  
    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;
  
      const p  = f.properties || {};
      const nm = p.name || p.Label || p.label || "PurpleAir";
      const pm = p.pm_corr ?? p.pm25 ?? p.PM2_5 ?? p["pm2.5"] ?? "N/A";
  
      L.circleMarker([ll.lat, ll.lon], {
        radius: 4,
        color: "#8000ff",
        weight: 1,
        fillOpacity: 0.7
      })
        .bindPopup(`<b>${nm}</b><br>PM2.5: ${pm} µg/m³`)
        .addTo(purpleLayerGroup);
    });
  
    console.log("[origin] plotted PurpleAir:", fc.features.length);
  }
  
  function plotNPRI(fc) {
    npriLayerGroup.clearLayers();
    if (!fc || !Array.isArray(fc.features)) return;
  
    fc.features.forEach(f => {
      const ll = getFeatureLatLon(f);
      if (!ll) return;
  
      const p   = f.properties || {};
      const fac = p.FACILITY_NAME || p.FacilityName || p.facility || "Facility";
      const co  = p.COMPANY_NAME  || p.Company      || p.company  || "";
      const yr  = p.REPORTING_YEAR || p.ReportingYear || p.year || "";
      const label = co ? `${fac} (${co})` : fac;
  
      L.circleMarker([ll.lat, ll.lon], {
        radius: 4,
        color: "#cc0000",
        weight: 1,
        fillOpacity: 0.8
      })
        .bindPopup(`
          <b>${label}</b><br>
          ${yr ? "Year: " + yr + "<br>" : ""}
          <small>${ll.lat.toFixed(4)}, ${ll.lon.toFixed(4)}</small>
        `)
        .addTo(npriLayerGroup);
    });
  
    console.log("[origin] plotted NPRI:", fc.features.length);
  }

  // ─────────────────────────────────────────
  // Once data are loaded, plot them on the map
  // ─────────────────────────────────────────
  Promise.all([
    window.stationsFCReady,
    window.purpleFCReady,
    window.npriFCReady
  ]).then(() => {
    console.log(
      "[origin] datasets loaded:",
      window.STATIONS_FC.features.length, "stations,",
      window.PURPLE_FC.features.length,   "purple,",
      window.NPRI_FC.features.length,     "npri"
    );

    // draw all three layers on initial load
    plotStations(window.STATIONS_FC);
    plotPurple(window.PURPLE_FC);
    plotNPRI(window.NPRI_FC);
  }).catch(err => {
    console.error("[origin] Promise.all error:", err);
  });

  
  // ─────────────────────────────────────────
  // Click handler: do everything client-side
  // ─────────────────────────────────────────
  map.on("click", async (e) => {
    const { lat, lng } = e.latlng;

    // Make sure the feature collections have finished loading
    await window.stationsFCReady;
    await window.purpleFCReady;
    await window.npriFCReady;

    console.log(
      "[origin click] FC sizes:",
      window.STATIONS_FC.features.length, "stations,",
      window.PURPLE_FC.features.length,   "purple,",
      window.NPRI_FC.features.length,     "npri"
    );


    // Clear previous trajectories/footprints
    trajLayerGroup.clearLayers();

    // receptor marker
    L.circleMarker(e.latlng, {
      radius: 6,
      color: "#000",
      weight: 2,
      fillColor: "#ff0000",
      fillOpacity: 0.9
    }).addTo(trajLayerGroup);

    try {
      // 1) Update wind from Open-Meteo at this click location
      await updateWindFromOpenMeteo(lat, lng);

      // 2) Compute trajectories using that wind
      const trajectories = await computeEnsembleTrajectories(lat, lng, {
        nParticles: 8,
        hoursBack: 2,
        dtMinutes: 10
      });

      const footprint = buildFootprint(trajectories);
      const dom = computeDominantDirection(trajectories);

      // 3) Draw on the map
      drawTrajectories(trajectories);
      drawFootprint(footprint);

      // 5) Search for upwind sources within the footprint
      const stationHits = pointsInFootprint(window.STATIONS_FC, footprint, 20); // ~20 km
      const purpleHits  = pointsInFootprint(window.PURPLE_FC,   footprint, 20);
      const npriHits    = pointsInFootprint(window.NPRI_FC,     footprint, 15);

      const receptorPt = turf.point([lng, lat]);

      // First: keep only stations that are in the upwind sector
      let stationUpwind = stationHits.filter(h => {
        const ll = getFeatureLatLon(h.feature);
        if (!ll) return false;
        const brg = bearingFromStationToReceptor(ll.lat, ll.lon, lat, lng);
        const stSector = bearingToSector(brg);
        return !dom.sector || stSector === dom.sector;
      });

      // Fallback: if none found inside footprint, take nearest stations
      // within 50 km that are in the same sector.
      if (!stationUpwind.length && window.STATIONS_FC && Array.isArray(window.STATIONS_FC.features)) {
        stationUpwind = window.STATIONS_FC.features
          .map(f => {
            const ll = getFeatureLatLon(f);
            if (!ll) return null;
            const fpt = turf.point([ll.lon, ll.lat]);
            const d   = turf.distance(receptorPt, fpt, { units: "kilometers" });
            const brg = bearingFromStationToReceptor(ll.lat, ll.lon, lat, lng);
            const stSector = bearingToSector(brg);
            return { feature: f, dist_km: d, sector: stSector };
          })
          .filter(h =>
            h &&
            h.dist_km <= 50 &&                             // within 50 km of receptor
            (!dom.sector || h.sector === dom.sector)      // same wind-from sector
          )
          .sort((a, b) => a.dist_km - b.dist_km)          // nearest first
          .slice(0, 3);                                   // top 3
      }



      
      // Fallback: if no upwind NPRI, show nearest facilities within 50 km of receptor
      let npriHitsFinal = npriHits;
      if (!npriHits.length && NPRI_FC && Array.isArray(NPRI_FC.features)) {
        const receptorPt = turf.point([lng, lat]);
      
        const allWithDist = NPRI_FC.features
          .map(f => {
            const ll = getFeatureLatLon(f);
            if (!ll) return null;
            const fpt = turf.point([ll.lon, ll.lat]);
            const d   = turf.distance(receptorPt, fpt, { units: "kilometers" });
            return { feature: f, dist_km: d };
          })
          .filter(Boolean)
          .sort((a, b) => a.dist_km - b.dist_km);
      
        npriHitsFinal = allWithDist.filter(h => h.dist_km <= 50).slice(0, 3);
      }


      // ----- AQ stations text -----
      let stationLines = "Aucun";
      if (stationUpwind.length) {
        stationLines = stationUpwind
          .slice(0, 3)
          .map(h => {
            const p   = h.feature.properties || {};
            const nm  = p.stationName || p.StationName || "Station";
            let aq    = p.aqhi ?? p.AQHI ?? "N/A";
            if (!isNaN(+aq)) aq = +aq > 10 ? "10+" : aq;
            const dkm = h.dist_km.toFixed(1);
            return `${nm} — AQHI: ${aq} (≈${dkm} km)`;
          })
          .join("<br>");
      }


      // ----- PurpleAir text -----
      let purpleLines = "Aucun";
      if (purpleHits.length) {
        purpleLines = purpleHits
          .slice(0, 3)
          .map(h => {
            const p   = h.feature.properties || {};
            const nm  = p.name || p.Label || p.label || "PurpleAir";
            // NEW: prefer pm_corr, then fallback
            const pm  = p.pm_corr ?? p.pm25 ?? p.PM2_5 ?? p["pm2.5"] ?? "N/A";
            const dkm = h.dist_km.toFixed(1);
            return `${nm} — PM2.5: ${pm} µg/m³ (≈${dkm} km)`;
          })
          .join("<br>");
      }



      // ----- NPRI text -----
      let npriLines = "Aucun";
      if (npriHitsFinal.length) {
        npriLines = npriHitsFinal
          .slice(0, 3)
          .map(h => {
            const p   = h.feature.properties || {};
            const fac = p.FACILITY_NAME || p.FacilityName || p.facility || "Installation NPRI";
            const co  = p.COMPANY_NAME  || p.Company      || p.company  || "";
            const yr  = p.REPORTING_YEAR || p.ReportingYear || p.year || "";
            const dkm = h.dist_km.toFixed(1);
            const label = co ? `${fac} (${co})` : fac;
            return `${label} — ${yr ? "Year " + yr + ", " : ""}≈${dkm} km`;
          })
          .join("<br>");
      }


      // 6) Popup summary
      const popupHtml = `
        <b>Air origin (last ~2 hours)</b><br/>
        Dominant upwind sector: <b>${dom.sector ?? "N/A"}</b><br/>
        Mean wind-from direction: ${
          dom.meanBearing !== null
            ? dom.meanBearing.toFixed(0) + "&deg;"
            : "N/A"
        }<br/>
        Ensemble members: ${dom.samples}<br/><br/>
        <b>Upwind AQ stations (~20 km):</b><br/>
        ${stationLines}<br/><br/>
        <b>Upwind PurpleAir sensors (~20 km):</b><br/>
        ${purpleLines}<br/><br/>
        <b>Upwind NPRI facilities (~15 km):</b><br/>
        ${npriLines}
      `;

      L.popup()
        .setLatLng(e.latlng)
        .setContent(popupHtml)
        .openOn(map);

    } catch (err) {
      console.error("Trajectory computation error:", err);
      alert("Could not compute trajectories. Check console for details.");
    }
  });

</script>

</body>
</html>
