<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Air Origin Map (GitHub-only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: system-ui, Arial, sans-serif;
      font-size: 13px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.2);
      max-width: 320px;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div class="info">
  Click the map to compute a simple backward trajectory ensemble (in browser).<br>
  Uses HRDPS winds via GeoMet WFS (no backend).
</div>

<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin="">
</script>

<script>
  // ─────────────────────────────────────────
  // Map setup
  // ─────────────────────────────────────────
  const map = L.map('map').setView([53.5, -113.5], 6);

  // Base tiles
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 10,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // Optional: overlay your HRDPS wind WMS for context
  // (purely visual; numeric values come from WFS below)
  L.tileLayer.wms("https://geo.weather.gc.ca/geomet/?lang=en", {
    layers: "HRDPS.CONTINENTAL_WSPD",
    format: "image/png",
    transparent: true,
    opacity: 0.5
  }).addTo(map);

  const trajLayerGroup = L.layerGroup().addTo(map);

  // ─────────────────────────────────────────
  // Numeric wind from GeoMet WFS  (HRDPS UU/VV)
  // ─────────────────────────────────────────

  async function getWindAt(lat, lon) {
    // For now we ignore lat/lon here and just use the lastWind
    // (which we update once per click from Open-Meteo).
    return lastWind;
  }




  // ─────────────────────────────────────────
  // Trajectory math helpers (JS versions)
  // ─────────────────────────────────────────
  const EARTH_RADIUS_M = 6371000.0;

  function uvToLatLonStep(latDeg, u, v, dtSeconds) {
    const latRad = latDeg * Math.PI / 180.0;
    let dlat = (v * dtSeconds) / EARTH_RADIUS_M * (180.0 / Math.PI);
    let dlon = (u * dtSeconds) / (EARTH_RADIUS_M * Math.cos(latRad)) * (180.0 / Math.PI);
    return { dlat, dlon };
  }

  function bearingDeg(lat1, lon1, lat2, lon2) {
    const phi1 = lat1 * Math.PI / 180.0;
    const phi2 = lat2 * Math.PI / 180.0;
    const dlon = (lon2 - lon1) * Math.PI / 180.0;

    const x = Math.sin(dlon) * Math.cos(phi2);
    const y = Math.cos(phi1) * Math.sin(phi2) -
              Math.sin(phi1) * Math.cos(phi2) * Math.cos(dlon);

    const brng = Math.atan2(x, y) * 180.0 / Math.PI;
    return (brng + 360.0) % 360.0;
  }

  function bearingToSector(bearing) {
    const labels = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
    const sectorSize = 360.0 / labels.length;
    const idx = Math.floor((bearing + sectorSize / 2.0) / sectorSize) % labels.length;
    return labels[idx];
  }

  
  // Global "current wind" used by the trajectories for the last click
  let lastWind = { u: 8, v: 1 };  // default until we fetch real data
  
  // Fetch real wind from Open-Meteo at the click location
  async function updateWindFromOpenMeteo(lat, lon) {
    const url = new URL("https://api.open-meteo.com/v1/forecast");
    url.searchParams.set("latitude", lat);
    url.searchParams.set("longitude", lon);
    url.searchParams.set("current_weather", "true");
  
    const resp = await fetch(url.toString());
    if (!resp.ok) {
      console.error("Open-Meteo error:", resp.status, resp.statusText);
      return;
    }
  
    const data = await resp.json();
    if (!data.current_weather) {
      console.warn("No current_weather in Open-Meteo response");
      return;
    }
  
    const speed_kmh = data.current_weather.windspeed;   // km/h
    const dir_deg   = data.current_weather.winddirection; // degrees FROM
  
    // Convert to m/s
    const speed_ms = speed_kmh / 3.6;
  
    // Open-Meteo direction = where the wind is COMING FROM (met convention)
    const dir_rad = dir_deg * Math.PI / 180.0;
  
    // Flow components (toward where air is going):
    // u = eastward, v = northward
    // Negative because direction is "from"
    const u = -speed_ms * Math.sin(dir_rad);
    const v = -speed_ms * Math.cos(dir_rad);
  
    lastWind = { u, v };
    console.log("Updated wind from Open-Meteo:", lastWind, "(dir from", dir_deg, "°)");
  }




  
  // ─────────────────────────────────────────
  // Core: compute ensemble trajectories in browser
  // ─────────────────────────────────────────
  async function computeEnsembleTrajectories(startLat, startLon, options = {}) {
    const nParticles = options.nParticles ?? 8;      // keep small for now
    const hoursBack  = options.hoursBack ?? 2.0;     // 2 hours for speed
    const dtMinutes  = options.dtMinutes ?? 10;      // 10-min steps
    const dtSeconds  = dtMinutes * 60.0;
    const nSteps     = Math.round(hoursBack * 60.0 / dtMinutes);

    const trajectories = [];

    for (let p = 0; p < nParticles; p++) {
      let lat = startLat + (Math.random() - 0.5) * 0.03;
      let lon = startLon + (Math.random() - 0.5) * 0.03;

      const traj = [{ lat, lon }];

      for (let k = 0; k < nSteps; k++) {
        const { u, v } = await getWindAt(lat, lon);   // HRDPS call

        const { dlat, dlon } = uvToLatLonStep(lat, u, v, dtSeconds);

        // backward = move opposite wind
        lat -= dlat;
        lon -= dlon;

        traj.push({ lat, lon });
      }

      trajectories.push(traj);
    }

    return trajectories;
  }

  function buildFootprint(trajectories, dlat = 0.05, dlon = 0.05) {
    const counts = new Map();

    for (const traj of trajectories) {
      for (const pt of traj) {
        const iy = Math.round(pt.lat / dlat);
        const ix = Math.round(pt.lon / dlon);
        const key = `${iy},${ix}`;
        counts.set(key, (counts.get(key) || 0) + 1);
      }
    }

    const cells = [];
    for (const [key, count] of counts.entries()) {
      const [iy, ix] = key.split(",").map(Number);
      cells.push({
        lat: iy * dlat,
        lon: ix * dlon,
        count
      });
    }
    return cells;
  }

function computeDominantDirection(trajectories) {
  const fromBearings = [];

  for (const traj of trajectories) {
    if (traj.length < 2) continue;

    // start = oldest point (upwind), end = receptor
    const start = traj[traj.length - 1];
    const end   = traj[0];

    // this is the direction of motion (from start → end)
    const motionBearing = bearingDeg(start.lat, start.lon, end.lat, end.lon);

    // meteorological convention: direction the air is COMING FROM
    const windFrom = (motionBearing + 180.0) % 360.0;

    fromBearings.push(windFrom);
  }

  if (!fromBearings.length) {
    return { sector: null, meanBearing: null, samples: 0 };
  }

  // mean "from" direction
  const meanFrom = fromBearings.reduce((a, b) => a + b, 0) / fromBearings.length;

  // convert to compass sectors (N, NE, E, …) using the "from" angles
  const sectorCounts = {};
  for (const b of fromBearings) {
    const s = bearingToSector(b);
    sectorCounts[s] = (sectorCounts[s] || 0) + 1;
  }
  const dominantSector = Object.entries(sectorCounts)
    .sort((a, b) => b[1] - a[1])[0][0];

  return {
    sector: dominantSector,      // e.g. "W" = wind FROM west
    meanBearing: meanFrom,       // numeric wind-from direction (deg)
    samples: fromBearings.length
  };
}


  // ─────────────────────────────────────────
  // Draw trajectories + footprint
  // ─────────────────────────────────────────
  function drawTrajectories(trajectories) {
    trajectories.forEach(traj => {
      const latlngs = traj.map(pt => [pt.lat, pt.lon]);
      L.polyline(latlngs, {
        weight: 2,
        opacity: 0.9
      }).addTo(trajLayerGroup);
    });
  }

  function drawFootprint(cells) {
    cells.forEach(cell => {
      const radius = 300 + cell.count * 80; // metres
      L.circle([cell.lat, cell.lon], {
        radius,
        weight: 0,
        fillOpacity: 0.25
      }).addTo(trajLayerGroup);
    });
  }

  // ─────────────────────────────────────────
  // Click handler: do everything client-side
  // ─────────────────────────────────────────
  map.on("click", async (e) => {
    const { lat, lng } = e.latlng;
    trajLayerGroup.clearLayers();

    // receptor marker
    L.circleMarker(e.latlng, { radius: 5 }).addTo(trajLayerGroup);

    try {
      // 1) Update wind from Open-Meteo at this click location
      await updateWindFromOpenMeteo(lat, lng);
  
      // 2) Now compute trajectories using that wind
      const trajectories = await computeEnsembleTrajectories(lat, lng, {
        nParticles: 8,
        hoursBack: 2,
        dtMinutes: 10
      });
  
      const footprint = buildFootprint(trajectories);
      const dom = computeDominantDirection(trajectories);
  
      drawTrajectories(trajectories);
      drawFootprint(footprint);
  
      const popupHtml = `
        <b>Air origin (last ~2 hours)</b><br/>
        Dominant upwind sector: <b>${dom.sector ?? "N/A"}</b><br/>
        Mean wind-from direction: ${
          dom.meanBearing !== null
            ? dom.meanBearing.toFixed(0) + "&deg;"
            : "N/A"
        }<br/>
        Ensemble members: ${dom.samples}
      `;
      // popup...

    
    try {
      // you can tweak these numbers later
      const trajectories = await computeEnsembleTrajectories(lat, lng, {
        nParticles: 8,
        hoursBack: 2,
        dtMinutes: 10
      });

      const footprint = buildFootprint(trajectories);
      const dom = computeDominantDirection(trajectories);

      drawTrajectories(trajectories);
      drawFootprint(footprint);

      const popupHtml = `
        <b>Air origin (last ~2 hours)</b><br/>
        Dominant upwind sector: <b>${dom.sector ?? "N/A"}</b><br/>
        Mean wind-from direction: ${
          dom.meanBearing !== null
            ? dom.meanBearing.toFixed(0) + "&deg;"
            : "N/A"
        }<br/>
        Ensemble members: ${dom.samples}
      `;

      L.popup()
        .setLatLng(e.latlng)
        .setContent(popupHtml)
        .openOn(map);

    } catch (err) {
      console.error("Trajectory error", err);
      alert("Error computing trajectories (check console)");
    }
  });
</script>

</body>
</html>
